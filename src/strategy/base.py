from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
import datetime

from ..data.models import Ticker, OrderBook, Trade, Candle
from ..execution.base import OrderSide, OrderType, OrderStatus
from ..execution.models import Order, Position, Account


class Strategy(ABC):
    """Base interface for all trading strategies."""
    
    @abstractmethod
    def initialize(self, config: Dict[str, Any]) -> None:
        """Initialize the strategy with configuration parameters."""
        pass
    
    @abstractmethod
    def on_ticker(self, ticker: Ticker, symbol: str, provider: str) -> None:
        """Process ticker updates."""
        pass
    
    @abstractmethod
    def on_orderbook(self, orderbook: OrderBook, symbol: str, provider: str) -> None:
        """Process orderbook updates."""
        pass
    
    @abstractmethod
    def on_trade(self, trade: Trade, symbol: str, provider: str) -> None:
        """Process trade updates."""
        pass
    
    @abstractmethod
    def on_candle(self, candle: Candle, symbol: str, interval: str, provider: str) -> None:
        """Process candle updates."""
        pass
    
    @abstractmethod
    def on_order_update(self, order: Order, broker: str) -> None:
        """Process order updates."""
        pass
    
    @abstractmethod
    def on_position_update(self, position: Position, broker: str) -> None:
        """Process position updates."""
        pass
    
    @abstractmethod
    def on_account_update(self, account: Account, broker: str) -> None:
        """Process account updates."""
        pass
    
    @abstractmethod
    def on_timer(self, timestamp: datetime.datetime) -> None:
        """Called periodically by the trading engine."""
        pass


class StrategySignal:
    """Represents a trading signal generated by a strategy."""
    
    def __init__(self, 
                 symbol: str, 
                 side: OrderSide, 
                 order_type: OrderType,
                 quantity: float,
                 price: Optional[float] = None,
                 stop_price: Optional[float] = None,
                 time_in_force: str = "GTC",
                 broker: str = None,
                 strategy_id: str = None,
                 metadata: Dict[str, Any] = None):
        self.symbol = symbol
        self.side = side
        self.order_type = order_type
        self.quantity = quantity
        self.price = price
        self.stop_price = stop_price
        self.time_in_force = time_in_force
        self.broker = broker
        self.strategy_id = strategy_id
        self.metadata = metadata or {}
        self.timestamp = datetime.datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "symbol": self.symbol,
            "side": self.side.value,
            "order_type": self.order_type.value,
            "quantity": self.quantity,
            "price": self.price,
            "stop_price": self.stop_price,
            "time_in_force": self.time_in_force,
            "broker": self.broker,
            "strategy_id": self.strategy_id,
            "metadata": self.metadata,
            "timestamp": self.timestamp.isoformat()
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'StrategySignal':
        """Create signal from dictionary."""
        return cls(
            symbol=data["symbol"],
            side=OrderSide(data["side"]),
            order_type=OrderType(data["order_type"]),
            quantity=data["quantity"],
            price=data.get("price"),
            stop_price=data.get("stop_price"),
            time_in_force=data.get("time_in_force", "GTC"),
            broker=data.get("broker"),
            strategy_id=data.get("strategy_id"),
            metadata=data.get("metadata", {})
        )
